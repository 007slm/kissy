/*
  Generated by kissy-kison.*/
KISSY.add("tests/cal", function () {
    /* Generated by kison from KISSY */
    var parser = {}, S = KISSY,
        REDUCE_TYPE = 2,
        SHIFT_TYPE = 1,
        ACCEPT_TYPE = 0;
    var Lexer = function (cfg) {

        /**
         * lex rules.
         * @type {Object[]}
         * @example
         * [
         *  {
         *   regexp:'\\w+',
         *   state:'xx',
         *   token:'c',
         *   // this => lex
         *   action:function(){}
         *  }
         * ]
         */
        this.rules = [];

        S.mix(this, cfg);

        S.each(this.rules, function (r) {
            if (!r.state) {
                r.state = Lexer.STATIC.INIT;
            }
        });

        /**
         * Input languages
         * @type {String}
         */

        this.resetInput(this.input);

    };
    Lexer.prototype = {
        "resetInput": function (input) {
            this.input = input;
            S.mix(this, {
                matched: "",
                stateStack: [Lexer.STATIC.INIT],
                match: "",
                text: "",
                firstLine: 1,
                lineNumber: 1,
                lastLine: 1,
                firstColumn: 1,
                lastColumn: 1
            });
        },
        "getCurrentRules": function () {
            var currentState = this.stateStack[this.stateStack.length - 1];
            var rules = [];
            S.each(this.rules, function (r) {
                if (r.state == currentState) {
                    rules.push(r);
                }
            });
            return rules;
        },
        "pushState": function (state) {
            this.stateStack.push(state);
        },
        "popState": function () {
            this.stateStack.pop();
        },
        "showDebugInfo": function () {
            var DEBUG_CONTEXT_LIMIT = Lexer.STATIC.DEBUG_CONTEXT_LIMIT;
            var matched = this.matched,
                match = this.match,
                input = this.input;
            matched = matched.slice(0, matched.length - match.length);
            var past = (matched.length > DEBUG_CONTEXT_LIMIT ? "..." : "") + matched.slice(-DEBUG_CONTEXT_LIMIT).replace(/\n/, " ");
            var next = match + input;
            next = next.slice(0, DEBUG_CONTEXT_LIMIT) + (next.length > DEBUG_CONTEXT_LIMIT ? "..." : "");
            return past + next + "\n" + new Array(past.length + 1).join("-") + "^";
        },
        "lex": function () {
            var self = this,
                input = self.input,
                i,
                rule,
                m,
                ret,
                lines,
                rules = self.getCurrentRules();

            self.match = self.text = "";

            if (!S.trim(input)) {
                return Lexer.STATIC.END_TAG;
            }

            for (i = 0; i < rules.length; i++) {
                rule = rules[i];
                if (m = input.match(rule.regexp)) {
                    lines = m[0].match(/\n.*/g);
                    if (lines) {
                        self.lineNumber += lines.length;
                    }
                    S.mix(self, {
                        firstLine: self.lastLine,
                        lastLine: self.lineNumber + 1,
                        firstColumn: self.lastColumn,
                        lastColumn: lines ? lines[lines.length - 1].length - 1 : self.lastColumn + m[0].length
                    });
                    var match;
                    // for error report
                    match = self.match = m[0];

                    // all matches
                    self.matches = m;
                    // may change by user
                    self.text = match;
                    // matched content utils now
                    self.matched += match;
                    ret = rule.action && rule.action.call(this);
                    if (ret == undefined) {
                        ret = rule.token;
                    }
                    input = input.slice(match.length);
                    self.input = input;

                    if (ret) {
                        return ret;
                    } else {
                        // ignore
                        return self.lex();
                    }
                }
            }

            S.error("lex error at line " + this.lineNumber + ":\n" + this.showDebugInfo());
        }
    };
    Lexer.STATIC = {
        "INIT": "init2",
        "DEBUG_CONTEXT_LIMIT": 20,
        "END_TAG": "$EOF"
    };
    var lexer = new Lexer({
        "rules": [{
            "regexp": /^\s+/,
            "state": "init2"
        }, {
            "regexp": /^[0-9]+(\.[0-9]+)?\b/,
            "token": "NUMBER",
            "state": "init2"
        }, {
            "regexp": /^\+/,
            "token": "+",
            "state": "init2"
        }, {
            "regexp": /^-/,
            "token": "-",
            "state": "init2"
        }, {
            "regexp": /^./,
            "token": "ERROR_LA",
            "state": "init2"
        }]
    });
    parser.lexer = lexer;
    parser.productions = [{
        "symbol": "$START",
        "rhs": ["expressions"],
        "action": undefined
    }, {
        "symbol": "expressions",
        "rhs": ["e"],
        "action": undefined
    }, {
        "symbol": "e",
        "rhs": ["e", "-", "e"],
        "action": function () {
            return this.$1 - this.$3;
        }
    }, {
        "symbol": "e",
        "rhs": ["e", "+", "e"],
        "action": function () {
            return this.$1 + this.$3;
        }
    }, {
        "symbol": "e",
        "rhs": ["NUMBER"],
        "action": function () {
            return Number(this.$1);
        }
    }];
    parser.table = {
        "gotos": {
            "0": {
                "expressions": 2,
                "e": 3
            },
            "4": {
                "e": 6
            },
            "5": {
                "e": 7
            }
        },
        "action": {
            "0": {
                "NUMBER": {
                    "type": 1,
                    "to": 1
                }
            },
            "1": {
                "$EOF": {
                    "type": 2,
                    "production": 4
                },
                "+": {
                    "type": 2,
                    "production": 4
                },
                "-": {
                    "type": 2,
                    "production": 4
                }
            },
            "2": {
                "$EOF": {
                    "type": 0
                }
            },
            "3": {
                "+": {
                    "type": 1,
                    "to": 4
                },
                "-": {
                    "type": 1,
                    "to": 5
                },
                "$EOF": {
                    "type": 2,
                    "production": 1
                }
            },
            "4": {
                "NUMBER": {
                    "type": 1,
                    "to": 1
                }
            },
            "5": {
                "NUMBER": {
                    "type": 1,
                    "to": 1
                }
            },
            "6": {
                "+": {
                    "type": 2,
                    "production": 3
                },
                "-": {
                    "type": 2,
                    "production": 3
                },
                "$EOF": {
                    "type": 2,
                    "production": 3
                }
            },
            "7": {
                "+": {
                    "type": 2,
                    "production": 2
                },
                "-": {
                    "type": 2,
                    "production": 2
                },
                "$EOF": {
                    "type": 2,
                    "production": 2
                }
            }
        }
    };
    parser.parse = function parse(input) {

        var self = this,
            lexer = self.lexer,
            state,
            symbol,
            action,
            table = self.table,
            gotos = table.gotos,
            tableAction = table.action,
            productions = self.productions,
            valueStack = [null],
            stack = [0];

        lexer.resetInput(input);

        while (1) {
            // retrieve state number from top of stack
            state = stack[stack.length - 1];

            if (!symbol) {
                symbol = lexer.lex();
            }

            if (!symbol) {
                S.log("it is not a valid input : " + input, "error");
                return false;
            }

            // read action for current state and first input
            action = tableAction[state] && tableAction[state][symbol];

            if (!action) {
                var expected = [];
                if (tableAction[state]) {
                    S.each(tableAction[state], function (_, symbol) {
                        expected.push(symbol);
                    });
                }
                S.error("parse error at line " + lexer.lineNumber + ":\n" + lexer.showDebugInfo() + "\n" + "expect " + expected.join(", "));
                return false;
            }

            switch (action.type) {

            case SHIFT_TYPE:

                stack.push(symbol);

                valueStack.push(lexer.text);

                // push state
                stack.push(action.to);

                // allow to read more
                symbol = null;

                break;

            case REDUCE_TYPE:

                var production = productions[action.production],
                    reducedSymbol = production.symbol,
                    reducedAction = production.action,
                    reducedRhs = production.rhs;

                var len = reducedRhs.length;

                var $$ = valueStack[valueStack.length - len]; // default to $$ = $1

                this.$$ = $$;

                for (var i = 0; i < len; i++) {
                    this["$" + (len - i)] = valueStack[valueStack.length - 1 - i];
                }

                var ret;

                if (reducedAction) {
                    ret = reducedAction.call(this);
                }

                if (ret !== undefined) {
                    $$ = ret;
                } else {
                    $$ = this.$$;
                }

                if (len) {
                    stack = stack.slice(0, - 1 * len * 2);
                    valueStack = valueStack.slice(0, - 1 * len);
                }

                stack.push(reducedSymbol);

                valueStack.push($$);

                var newState = gotos[stack[stack.length - 2]][stack[stack.length - 1]];

                stack.push(newState);

                break;

            case ACCEPT_TYPE:

                return $$;
            }

        }

        return undefined;

    };
    return parser;;
});